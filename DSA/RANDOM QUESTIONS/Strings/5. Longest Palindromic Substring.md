Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.

**Example 1:**

**Input:** s = "babad"
**Output:** "bab"
**Explanation:** "aba" is also a valid answer.

**Example 2:**

**Input:** s = "cbbd"
**Output:** "bb"

---

# BruteForce Approach: 

###  **Function:** `longestPalindrome(String s)`
• **Step 1:**  
 → Initialize `n = s.length()` and an empty string `ans` to store the longest palindrome found so far.

• **Step 2:**  
 → Use two nested loops to check every possible substring of `s`:  
  – Outer loop (`i`) → starting index of substring.  
  – Inner loop (`j`) → ending index of substring.  
 → Extract the substring: `String str = s.substring(i, j + 1)`.

• **Step 3:**  
 → For each substring, call `isPalindrome(str)` to check if it’s a palindrome.  
 → If it is and `str` is longer than the current `ans`, update `ans = str`.

• **Step 4:**  
 → After all substrings are checked, return `ans` as the longest palindrome.

###  **Helper Function:** `isPalindrome(String s)`

• **Goal:**  
 → Check if a given string `s` is a palindrome.

• **Logic:**  
 → Initialize two pointers:  
  – `start = 0` (beginning of string)  
  – `end = s.length() - 1` (end of string).  
 → Compare characters from both ends while moving inward.  
 → If any mismatch is found, return `false`.  
 → If all pairs match, return `true`.



```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        String ans = ""; // To store the longest palindrome found

        // Check all possible substrings
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                // Extract substring from i to j
                String str = s.substring(i, j + 1);

                // If substring is a palindrome and longer than the current answer
                if (isPalindrome(str)) {
                    if (ans.length() < str.length()) {
                        ans = str; // Update answer
                    }
                }
            }
        }

        // Return the longest palindrome substring found
        return ans;
    }

    // Helper function to check if a given string is a palindrome
    public boolean isPalindrome(String s) {
        int start = 0;
        int end = s.length() - 1;

        // Compare characters from both ends moving inward
        while (start < end) {
            if (s.charAt(start) != s.charAt(end)) {
                return false; // Not a palindrome
            }
            start++;
            end--;
        }
        return true; // All characters matched
    }
}

```


---

# Optimal Approach:- 

### **Function:** `longestPalindrome(String s)`

• **Step 1:**  
 → Initialize variables:  
  – `start` and `end` to store the beginning and end indices of the longest palindrome found.

• **Step 2:**  
 → Loop through each index `i` in the string.  
 → Treat each index as the **center** of a possible palindrome.

  – Call `expandFromCenter(s, i, i)` → checks for **odd-length** palindromes (single character center).  
  – Call `expandFromCenter(s, i, i + 1)` → checks for **even-length** palindromes (two-character center).

 → Take the longer result between the two as `maxLen`.

• **Step 3:**  
 → If the found palindrome is longer than the previous one (`end - start < maxLen`):  
  – Update `start = i - (maxLen - 1) / 2`.  
  – Update `end = i + maxLen / 2`.

• **Step 4:**  
 → After checking all centers, return `s.substring(start, end + 1)` as the **longest palindrome**.

###  **Helper Function:** `expandFromCenter(String s, int left, int right)`

• **Goal:**  
 → Expand around the given center (`left`, `right`) while characters on both sides are equal.  
 → Stop when characters differ or go out of bounds.  
 → Return the **length of the palindrome** found (`right - left - 1`).


```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        int start = 0, end = 0; // store the start and end indices of the longest palindrome found

        // Loop through each character, treating it as the center of a possible palindrome
        for (int i = 0; i < len; i++) {
            // Case 1: Odd length palindrome (center at one character)
            int odd = expandFromCenter(s, i, i);

            // Case 2: Even length palindrome (center between two characters)
            int even = expandFromCenter(s, i, i + 1);

            // Take the larger palindrome length
            int maxLen = Math.max(odd, even);

            // If we found a longer palindrome, update start and end indices
            if (end - start < maxLen) {
                start = i - (maxLen - 1) / 2; // move left pointer correctly
                end = i + maxLen / 2;         // move right pointer correctly
            }
        }

        // Extract and return the longest palindromic substring
        return s.substring(start, end + 1);
    }

    // Helper function: expand around the center and return palindrome length
    public int expandFromCenter(String s, int left, int right) {
        // Expand while characters on both sides match
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // Return length of the palindrome found
        return right - left - 1;
    }
}

```