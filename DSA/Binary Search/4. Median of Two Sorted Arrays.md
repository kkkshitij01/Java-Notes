
Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

**Example 1:**

**Input:** nums1 = `[1,3], nums2 = [2]`
**Output:** 2.00000
**Explanation:** merged array = `[1,2,3]` and median is 2.

**Example 2:**

**Input:** nums1 = `[1,2], nums2 = [3,4]`
**Output:** 2.50000
**Explanation:** merged array = `[1,2,3,4] `and median is (2 + 3) / 2 = 2.5.


# Optimal Approach:
- **Function Name:** `findMedianSortedArrays()`
    - This function finds the **median** of two sorted arrays without merging them.        
    - It checks which array is smaller and then calls the helper function `solve()` on it to perform binary search efficiently.


- **Function Name:** `solve()`
    - Performs **binary search** on the smaller array to find the correct partition.

    - **Step 1:** Initialize `low = 0` and `high = s1` where `s1` is the size of the smaller array.        

    - **Step 2:** While `low <= high`, calculate  
        `firstCut = (low + high) / 2` and  
        `secondCut = (s1 + s2 + 1) / 2 - firstCut`  
        → These represent how many elements are in the left half from each array.
    
    - **Step 3:** Define boundary values —  
        `l1`, `l2` → largest elements on the left sides of both partitions.  
        `r1`, `r2` → smallest elements on the right sides of both partitions.

        
    - **Step 4:** Check if the partition is correct —  
        If `l1 <= r2` **and** `l2 <= r1`, it means all left-side elements are smaller than right-side elements.        
        - If total elements are **even**, return `(max(l1, l2) + min(r1, r2)) / 2.0`
        - If total elements are **odd**, return `max(l1, l2)`
    
    - **Step 5:** If partition is wrong, move binary search accordingly —    
        - If `l1 > r2`, move left → `high = firstCut - 1`
        - Else move right → `low = firstCut + 1`

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int s1 = nums1.length; 
        int s2 = nums2.length; 

        // We always binary search on the smaller array
        // to make the search more efficient
        if (s1 < s2) {
            return solve(nums1, nums2, s1, s2);
        } else {
            return solve(nums2, nums1, s2, s1);
        }
    }

    public double solve(int[] first, int[] second, int s1, int s2) {
        int low = 0;
        int high = s1;

        // Binary search on the first (smaller) array
        while (low <= high) {
            // mid point in the first array
            int firstCut = (low + high) / 2;

            // find the matching cut in the second array
            int secondCut = (s1 + s2 + 1) / 2 - firstCut;

            // left side elements of both arrays
            int l1 = (firstCut == 0) ? Integer.MIN_VALUE : first[firstCut - 1];
            int l2 = (secondCut == 0) ? Integer.MIN_VALUE : second[secondCut - 1];

            // right side elements of both arrays
            int r1 = (firstCut == s1) ? Integer.MAX_VALUE : first[firstCut];
            int r2 = (secondCut == s2) ? Integer.MAX_VALUE : second[secondCut];

            // Check if we have a correct partition
            if (l1 <= r2 && l2 <= r1) {
                int maxLeft = Math.max(l1, l2); // biggest of left parts

                // If total length is even, take average of middle two
                if ((s1 + s2) % 2 == 0) {
                    return (maxLeft + Math.min(r1, r2)) / 2.0;
                }

                // If total length is odd, median is max of left side
                return maxLeft;

            } else if (l1 > r2) {
                // We cut too much from the first array — move left
                high = firstCut - 1;
            } else {
                // We cut too little — move right
                low = firstCut + 1;
            }
        }

        // Should never reach here if inputs are valid
        return -1;
    }
}

```