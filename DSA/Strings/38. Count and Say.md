The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:

- `countAndSay(1) = "1"`
- `countAndSay(n)` is the run-length encoding of `countAndSay(n - 1)`.

RLE(run length encoding) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string `"3322251"` we replace `"33"` with `"23"`, replace `"222"` with `"32"`, replace `"5"` with `"15"` and replace `"1"` with `"11"`. Thus the compressed string becomes `"23321511"`.

Given a positive integer `n`, return _the_ `nth` _element of the **count-and-say** sequence_.

**Example 1:**

**Input:** n = 4

**Output:** "1211"

**Explanation:**

countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"

**Example 2:**

**Input:** n = 1

**Output:** "1"

**Explanation:**

This is the base case.

---

# Approach:- 
### **• Step 1 — Initialize the first term**

- Start with `ans = "1"` because the first term of the sequence is `"1"`.
    

---

### **• Step 2 — Generate terms from 2 to n**

- Use a loop that runs `n - 1` times.
    
- Each loop iteration transforms the current string into the next term.
    

---

### **• Step 3 — Scan the current term**

- Set a pointer `ptr = 0`.
    
- Create a `StringBuilder sb` to build the new term.
    
- While `ptr` is within the string:
    
    - Read `ch = ans.charAt(ptr)` → the current character.
        
    - Count how many times `ch` repeats consecutively.
        

---

### **• Step 4 — Count consecutive characters**

- Initialize `count = 0`.
    
- While the pointer is inside the string **and** the character matches `ch`:
    
    - Increase `count`.
        
    - Move the pointer to the next position.
        

---

### **• Step 5 — Form the next part of the term**

- Append the `count` followed by the character `ch` to the new string:
    
    `sb.append(count); sb.append(ch);`
    

---

### **• Step 6 — Update the term**

- After the full scan completes, convert `sb` to a string →
    
    `ans = sb.toString();`
    
- This new value of `ans` becomes the next term to process.
    

---

## **• Step 7 — Return the final term**

- When the loop finishes, return `ans` as the **n-th Count and Say** result.

```java
class Solution {
    public String countAndSay(int n) {
        String ans = "1"; // starting term
        // build terms from 2 to n
        
        for (int i = 0; i < n - 1; i++) {
            int ptr = 0;
            StringBuilder sb = new StringBuilder();

            // scan the current string and form the next one
            while (ptr < ans.length()) {
                int count = 0;
                char ch = ans.charAt(ptr); // current character to count

                // count how many times this character appears consecutively
                while (ptr < ans.length() && ans.charAt(ptr) == ch) {
                    ptr++;
                    count++;
                }
                // add "count + character" to the new string
                sb.append(count);
                sb.append(ch);
            }
            ans = sb.toString(); // update for next round
        }
        return ans;
    }
}

```