Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer.

The algorithm for `myAtoi(string s)` is as follows:

1. **Whitespace**: Ignore any leading whitespace (`" "`).
2. **Signedness**: Determine the sign by checking if the next character is `'-'` or `'+'`, assuming positivity if neither present.
3. **Conversion**: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.
4. **Rounding**: If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then round the integer to remain in the range. Specifically, integers less than `-231` should be rounded to `-231`, and integers greater than `231 - 1` should be rounded to `231 - 1`.

Return the integer as the final result.

**Example 1:**

**Input:** s = "42"

**Output:** 42

**Explanation:**

The underlined characters are what is read in and the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
Step 2: "42" (no characters read because there is neither a '-' nor '+')
Step 3: "42" ("42" is read in)


**Example 2:**

**Input:** s = " -042"

**Output:** -42

**Explanation:**

Step 1: "   -042" (leading whitespace is read and ignored)
Step 2: "   -042" ('-' is read, so the result should be negative)
Step 3: "   -042" ("042" is read in, leading zeros ignored in the result)

**Example 3:**

**Input:** s = "1337c0d3"

**Output:** 1337

**Explanation:**

Step 1: "1337c0d3" (no characters read because there is no leading whitespace)
Step 2: "1337c0d3" (no characters read because there is neither a '-' nor '+')
Step 3: "1337c0d3" ("1337" is read in; reading stops because the next character is a non-digit)

**Example 4:**

**Input:** s = "0-1"

**Output:** 0

**Explanation:**

Step 1: "0-1" (no characters read because there is no leading whitespace)
Step 2: "0-1" (no characters read because there is neither a '-' nor '+')
Step 3: "0-1" ("0" is read in; reading stops because the next character is a non-digit)

---
# Approach : 
### **Function:** `myAtoi(String s)`

• **Goal:**  
 - Convert a given string `s` into a 32-bit signed integer (similar to C/C++ `atoi()`).  
 - Handle spaces, signs (`+`/`-`), invalid characters, and overflow correctly.

• **Step 1:**  
 - Remove leading and trailing spaces using `s.trim()`.  
 - If the trimmed string is empty, return `0`.

• **Step 2:**  
 - Initialize variables:  
  • `isNegative = false` → to track the sign  
  • `ans = 0` (use long to detect overflow early)  
  • `i = 0` → pointer to traverse characters

• **Step 3:**  
 - Check if the first character is a sign (`+` or `-`).  
 - If it is `'-'`, set `isNegative = true`.  
 - Move `i` forward to skip the sign.

• **Step 4:**  
 - Loop while `i < s.length()` and current character is a **digit**:  
  • Convert digit: `numb = s.charAt(i) - '0'`  
  • Update total: `ans = ans * 10 + numb`  
  • Check for overflow:  
   - If `ans > Integer.MAX_VALUE`, return `Integer.MAX_VALUE`  
   - If `-ans < Integer.MIN_VALUE`, return `Integer.MIN_VALUE`  
  • Increment `i` to continue reading digits

• **Step 5:**  
 - Apply the sign to the final number:  
  • If `isNegative` → return `-(int) ans`  
  • Else → return `(int) ans`

```java
class Solution {
    public int myAtoi(String s) {

        // Track sign of the number
        boolean isNegative = false;

        // Step 1: Remove leading spaces
        s = s.trim();

        // If empty after trimming, return 0
        if (s.length() == 0)
            return 0;

        int len = s.length();
        int i = 0;
        long ans = 0; // use long to safely detect overflow

        // Step 2: Check if the first character is '+' or '-'
        if (s.charAt(i) == '+' || s.charAt(i) == '-') {
            if (s.charAt(i) == '-') {
                isNegative = true;  // mark number as negative
            }
            i++; // move to next character after the sign
        }

        // Step 3: Convert digits until a non-digit character is found
        while (i < len && Character.isDigit(s.charAt(i))) {
            int numb = s.charAt(i) - '0';  // convert char to number
            ans = ans * 10 + numb;         // build the number
            i++;

            // Step 4: If number goes beyond 32-bit range, restrict it
            if (isNegative) {
                if (-ans < Integer.MIN_VALUE) {
                    return Integer.MIN_VALUE; // restrict to minimum allowed value
                }
            } else {
                if (ans > Integer.MAX_VALUE) {
                    return Integer.MAX_VALUE; // restrict to maximum allowed value
                }
            }
        }

        // Step 5: Apply sign and return result
        return isNegative ? -(int) ans : (int) ans;
    }
}

```