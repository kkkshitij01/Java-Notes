Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

**Input:** height = `[0,1,0,2,1,0,1,3,2,1,2,1]`
**Output:** 6
**Explanation:** The above elevation map (black section) is represented by array `[0,1,0,2,1,0,1,3,2,1,2,1]`. In this case, 6 units of rain water (blue section) are being trapped.

**Example 2:**

**Input:** height = `[4,2,0,3,2,5]`
**Output:** 9

---


# BruteForce 

• Input array `height[]` → represents heights of bars.  
• Let `n = height.length`.  
• Create two arrays:  
 – `left[]` → stores maximum height seen from the **left** up to each index.  
 – `right[]` → stores maximum height seen from the **right** up to each index.

• Initialize edges:  
 – `left[0] = height[0]` → first bar is the left boundary.  
 – `right[n-1] = height[n-1]` → last bar is the right boundary.

• Fill the `right[]` array (from right to left):  
 – For `i = n-2` down to `0`:  
  `right[i] = max(height[i], right[i+1])`  
  → Each position stores the tallest bar to its **right side**, including itself.

• Fill the `left[]` array (from left to right):  
 – For `i = 1` to `n-1`:  
  `left[i] = max(height[i], left[i-1])`  
  → Each position stores the tallest bar to its **left side**, including itself.

• Initialize `vol = 0` → total trapped water.

• Calculate trapped water for each index `i`:  
 – Find the possible water level: `a = min(left[i], right[i])`  
  → Water can only rise up to the shorter of the two boundaries.  
 – Add trapped water: `vol += a - height[i]`  
  → Difference between water level and bar height gives water trapped above that bar.

• Return `vol` → total trapped rainwater.

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        
        // Arrays to store the maximum height to the left and right of each bar
        int left[] = new int[n];
        int right[] = new int[n];
        
        // Initialize edges
        right[n - 1] = height[n - 1];  // Last element on the right
        left[0] = height[0];           // First element on the left
        
        // Fill the right array (max height seen from the right side)
        for (int i = n - 2; i >= 0; i--) {
            right[i] = Math.max(height[i], right[i + 1]);
        }
        
        // Fill the left array (max height seen from the left side)
        for (int i = 1; i < n; i++) {
            left[i] = Math.max(height[i], left[i - 1]);
        }
        
        int vol = 0; // To store total trapped water
        
        // Calculate trapped water at each bar
        for (int i = 0; i < n; i++) {
            int a = Math.min(left[i], right[i]); // Water level limited by shorter side
            vol += Math.abs(a - height[i]);      // Add trapped water (if any)
        }
        
        // Return total trapped water
        return vol;
    }
}

```


---

# Optimal : Two Pointer Approach

• Input array `height[]` → heights of bars forming the elevation map.  
• Initialize `leftMax = 0` → stores highest bar seen from the left.  
• Initialize `rightMax = 0` → stores highest bar seen from the right.  
• Set two pointers:  
 – `left = 0` (start of array)  
 – `right = height.length - 1` (end of array)  
• Initialize `vol = 0` → total trapped water.

• Use a **two-pointer approach** to traverse from both ends:  
 – While `left < right`:  
  • Compare `height[left]` and `height[right]`.

  • If `height[left] < height[right]`:  
   – If `height[left] > leftMax`, update `leftMax = height[left]`.  
   – Else, water can be trapped → `vol += leftMax - height[left]`.  
   – Move `left++` (inward).

  • Else (`height[right] <= height[left]`):  
   – If `height[right] > rightMax`, update `rightMax = height[right]`.  
   – Else, water can be trapped → `vol += rightMax - height[right]`.  
   – Move `right--` (inward).

• Continue until both pointers meet.  
• Return `vol` → total amount of trapped water.
```java
class Solution {
    public int trap(int[] height) {
        int leftMax = 0;   // Highest bar seen from the left
        int rightMax = 0;  // Highest bar seen from the right
        int left = 0;      // Left pointer
        int right = height.length - 1; // Right pointer
        int vol = 0;       // Total trapped water volume
        
        // Use two-pointer approach
        while (left < right) {
            // Compare left and right bar heights
            if (height[left] < height[right]) {
                // If current left bar is higher than leftMax, update it
                if (leftMax < height[left]) {
                    leftMax = height[left];
                } else {
                    // Else, water can be trapped above this bar
                    vol += leftMax - height[left];
                }
                left++; // Move left pointer inward
            } else {
                // If current right bar is higher than rightMax, update it
                if (rightMax < height[right]) {
                    rightMax = height[right];
                } else {
                    // Else, water can be trapped above this bar
                    vol += rightMax - height[right];
                }
                right--; // Move right pointer inward
            }
        }
        // Return total trapped water
        return vol;
    }
}

```