You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

Return _the single element that appears only once_.

Your solution must run in `O(log n)` time and `O(1)` space.

**Example 1:**

**Input:** `nums = [1,1,2,3,3,4,4,8,8]`
**Output:** 2

**Example 2:**

**Input:**` nums = [3,3,7,7,10,11,11]`
**Output:** 10

---


# BruteForce 

• Let `n = nums.length`.  
• If the array has only one element → directly return `nums[0]`.  
• Loop through each element:  
 → **If `i == 0` (first element):** check if `nums[0] != nums[1]`. If true → return `nums[0]`.  
 → **If `i == n-1` (last element):** check if `nums[n-1] != nums[n-2]`. If true → return `nums[n-1]`.  
 → **Otherwise:** for middle elements, check if both neighbors are different → `nums[i] != nums[i-1] && nums[i] != nums[i+1]`. If true → return `nums[i]`.  
• If no such element found (shouldn’t happen for valid input), return `-1`.  
• **Time Complexity:** O(n) – checks each element once.  
• **Space Complexity:** O(1) – no extra space used.

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n = nums.length;

        // If there's only one element, return it
        if (n == 1) return nums[0];

        // Loop through the array to find the single element
        for (int i = 0; i < n; i++) {

            // If the first element is unique (not equal to the next one)
            if (i == 0) {
                if (nums[i] != nums[i + 1]) {
                    return nums[i];
                }
            } 
            // If the last element is unique (not equal to the previous one)
            else if (i == n - 1) {
                if (nums[i] != nums[i - 1]) {
                    return nums[i];
                }
            } 
            // For middle elements, check both neighbors
            else {
                if (nums[i] != nums[i - 1] && nums[i] != nums[i + 1]) {
                    return nums[i];
                }
            }
        }

        // If no unique element is found (edge case)
        return -1;
    }
}

```


---
# Optimal Approach 1 : (clean code)

• Let `n = nums.length`.  
• Handle **edge cases** first:  
 → If only one element → return `nums[0]`.  
 → If first element ≠ second → return `nums[0]`.  
 → If last element ≠ second last → return `nums[n-1]`.  
• Initialize binary search range → `start = 1`, `end = n-2`.  
• While `start <= end`:  
 → Compute `mid = (start + end) / 2`.  
 → If `nums[mid]` ≠ both neighbors → return `nums[mid]` (unique element).  
 → Use pattern observation:  
  – Before the single element → pairs start at **even indices**.  
  – After the single element → pairs start at **odd indices**.  
 → If (`mid` is odd and `nums[mid] != nums[mid-1]`) **or** (`mid` is even and `nums[mid] != nums[mid+1]`) → unique lies **left** → `end = mid - 1`.  
 → Else → unique lies **right** → `start = mid + 1`.  
• If no element found (shouldn’t happen for valid input) → return `-1`.  
• **Time Complexity:** O(log n) – binary search halves the range each step.  
• **Space Complexity:** O(1) – constant extra space.

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n = nums.length;

        // Handle simple edge cases
        if (n == 1) {                           // Only one element in the array
            return nums[0];
        } else if (nums[0] != nums[1]) {        // Unique element is the first one
            return nums[0];
        } else if (nums[n - 1] != nums[n - 2]) { // Unique element is the last one
            return nums[n - 1];
        }

        int start = 1;
        int end = n - 2;

        // Binary search for the single unique element
        while (start <= end) {
            int mid = (start + end) / 2;

            // If element at mid is not equal to its neighbors, it’s the unique one
            if (nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1]) {
                return nums[mid];
            }

            // Check pattern to decide which half to search next:
            // Before the single element — pairs start at even indices
            // After the single element — pairs start at odd indices
            if ((mid % 2 == 1 && nums[mid] != nums[mid - 1]) ||
                (mid % 2 == 0 && nums[mid] != nums[mid + 1])) {
                end = mid - 1;   // Move to the left half
            } else {
                start = mid + 1; // Move to the right half
            }
        }

        // If no unique element is found (should not happen for valid input)
        return -1;
    }
}

```
 
---


# Optimal Approach 2 : 

• Let `n = nums.length`.  
• If there’s only one element → directly return `nums[0]`.  
• Initialize two pointers → `start = 0`, `end = n - 1`.  
• Use **binary search** to find the unique element efficiently.  
• While `start <= end`:  
 → Find `mid = (start + end) / 2`.  
 → If `check(nums, mid)` returns true → `nums[mid]` is the unique element → return it.  
 → If `mid` is **odd** and `nums[mid] != nums[mid - 1]` → single element is in **left half** → move `end = mid - 1`.  
 → Else if `mid` is **even** and `nums[mid] != nums[mid + 1]` → single element is in **left half** → move `end = mid - 1`.  
 → Otherwise → move to **right half** → `start = mid + 1`.  
• If not found (shouldn’t happen for valid input) → return `-1`.  
• **Helper function:** `check(nums, idx)` verifies if the current element is unique.  
 → If `idx == 0` → unique if `nums[0] != nums[1]`.  
 → If `idx == n-1` → unique if `nums[n-1] != nums[n-2]`.  
 → Otherwise → unique if `nums[idx]` differs from both neighbors.  
• **Time Complexity:** O(log n) – binary search halves the range each step.  
• **Space Complexity:** O(1) – no extra space used.

``` java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n = nums.length;

        // If there’s only one element, return it
        if (n == 1)
            return nums[0];

        int start = 0;
        int end = n - 1;

        // Binary search for the single element
        while (start <= end) {
            int mid = (start + end) / 2;

            // Check if the middle element is the unique one
            if (check(nums, mid)) {
                return nums[mid];
            }

            // If mid is odd and doesn't match the left element,
            // the single element lies on the left half
            if (mid % 2 == 1 && nums[mid] != nums[mid - 1]) {
                end = mid - 1;
            }
            // If mid is even and doesn't match the right element,
            // the single element lies on the left half
            else if (mid % 2 == 0 && nums[mid] != nums[mid + 1]) {
                end = mid - 1;
            }
            // Otherwise, move to the right half
            else {
                start = mid + 1;
            }
        }

        // If not found (shouldn’t happen for valid input)
        return -1;
    }

    // Helper function to check if nums[idx] is the unique element
    public boolean check(int nums[], int idx) {
        if (idx == 0) {
            // First element unique if not equal to next
            return nums[idx] != nums[idx + 1];
        } 
        else if (idx == nums.length - 1) {
            // Last element unique if not equal to previous
            return nums[idx] != nums[idx - 1];
        } 
        else {
            // Middle element unique if not equal to neighbors
            return nums[idx] != nums[idx - 1] && nums[idx] != nums[idx + 1];
        }
    }
}

```


