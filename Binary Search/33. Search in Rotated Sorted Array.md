


There is an integer array `nums` sorted in ascending order (with **distinct** values).
Prior to being passed to your function, `nums` is **possibly left rotated** at an unknown index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be left rotated by `3` indices and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

**Input:** nums = `[4,5,6,7,0,1,2]`, target = 0
**Output:** 4

**Example 2:**

**Input:** nums = `[4,5,6,7,0,1,2],` target = 3
**Output:** -1

**Example 3:**

**Input:** nums = `[1],` target = 0
**Output:** -1

---
# BruteForce 

- You linearly check each element until you find `target`.
- If found, return the index immediately.
- If the loop finishes without a match, return `-1`.


```java
class Solution {
    public int search(int[] nums, int target) {
        // Loop through all elements
        for (int i = 0; i < nums.length; i++) {
            // If target is found, return its index
            if (target == nums[i]) {
                return i;
            }
        }
        // If not found, return -1
        return -1;
    }
}

```



---

# Optimal Solution : 

• Initialize two pointers:  
 → `low = 0` (start of array)  
 → `high = nums.length - 1` (end of array)

• Run a loop while `low <= high`:  
 → Calculate `mid = (low + high) / 2`.  
 → If `nums[mid] == target`, return `mid`.

• Determine which half is sorted:  
 → If `nums[mid] >= nums[low]`, then **left half is sorted**.  
  – If `target` lies within this range (`target >= nums[low] && target < nums[mid]`), move search to left: `high = mid - 1`.  
  – Else, search in right half: `low = mid + 1`.

 → Else, **right half is sorted**.  
  – If `target` lies within this range (`target <= nums[high] && target > nums[mid]`), move search to right: `low = mid + 1`.  
  – Else, move search to left: `high = mid - 1`.

• If the loop ends and no match is found, return `-1`.

```java
class Solution {

    public int search(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;

        // Binary search loop
        while (low <= high) {

            int mid = (low + high) / 2; // Find middle index

            // If target found at mid
            if (nums[mid] == target) {
                return mid;
            }

            // Check if the left half is sorted
            if (nums[mid] >= nums[low]) {

                // If target lies in the left sorted part
                if (target >= nums[low] && target < nums[mid]) {
                    high = mid - 1;
                } else { // Otherwise, go to the right part
                    low = mid + 1;
                }

            } else { 
                // Otherwise, the right half is sorted

                // If target lies in the right sorted part
                if (target <= nums[high] && target > nums[mid]) {
                    low = mid + 1;
                } else { // Otherwise, go to the left part
                    high = mid - 1;
                }
            }
        }

        // If not found, return -1
        return -1;
    }
}

```