Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.

`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

`**Input:** head = [1,2,3,4,5], k = 2`
`**Output:** [2,1,4,3,5]`

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

`**Input:** head = [1,2,3,4,5], k = 3`
`**Output:** [3,2,1,4,5]`


---
# Optimal Approach:


• **Step 1:**  
 – Move a temporary pointer forward `k` times to check if `k` nodes exist.  
 – If `temp` becomes `null` before finishing `k` steps → return `head` (not enough nodes to reverse).

• **Step 2:**  
 – Recursively call `reverseKGroup(temp, k)` to reverse the remaining part of the list.  
 – Store the returned head in `prev`. This will be attached at the end of the current reversed block.

• **Step 3:**  
 – Reverse the current group of `k` nodes:  
  • For each of the `k` nodes:  
   – Store `temp.next` in `upNext`.  
   – Point `temp.next` to `prev`.  
   – Move `prev` to `temp`.  
   – Move `temp` to `upNext`.

• **Step 4:**  
 – After reversing `k` nodes, `prev` becomes the new head of this group.  
 – Return `prev` as the new head of the reversed block.

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {

        ListNode temp = head;
        int count = 0;

        // Check if we have at least k nodes to reverse
        while (count < k) {
            if (temp == null) {
                return head; // fewer than k nodes → return list as it is
            }
            temp = temp.next;
            count++;
        }

        // Recursively reverse the rest of the list starting from 'temp'
        ListNode prev = reverseKGroup(temp, k);

        // Now reverse current group of k nodes
        temp = head;
        count = 0;

        // Reverse exactly k nodes using pointer manipulation
        while (count < k) {
            ListNode upNext = temp.next; // store next node
            temp.next = prev;            // reverse pointer
            prev = temp;                 // move prev forward
            temp = upNext;               // move current pointer forward
            count++;
        }

        // 'prev' now points to the new head of this reversed group
        return prev;
    }
}


```