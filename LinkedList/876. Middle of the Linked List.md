Given the `head` of a singly linked list, return _the middle node of the linked list_.

If there are two middle nodes, return **the second middle** node.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)

**Input:** head =` [1,2,3,4,5]
**Output:**` [3,4,5]
**Explanation:** The middle node of the list is node 3.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)

**Input:** head` = [1,2,3,4,5,6]
**Output:** `[4,5,6]
**Explanation:** Since the list has two middle nodes with values 3 and 4, we return the second one.

---
# Optimal Approach:

• **Step 1:**  
 → Create two pointers:  
  – `slow` → moves **1 step** at a time.  
  – `fast` → moves **2 steps** at a time.

• **Step 2:**  
 → Traverse the list while `fast != null && fast.next != null`.  
 → In each iteration:  
  – Move `slow = slow.next`.  
  – Move `fast = fast.next.next`.

• **Step 3:**  
 → When the loop ends, `fast` is at the end (or null if even length).  
 → At this point, `slow` points to the **middle** of the list.

• **Step 4:**  
 → Return `slow`.  
 → For even-length lists, this automatically returns the **second middle node**.

```java

class Solution {

    public ListNode middleNode(ListNode head) {

        // 'slow' moves one step at a time
        ListNode slow = head;

        // 'fast' moves two steps at a time
        ListNode fast = head;

        // Loop runs until 'fast' reaches the end of the list
        while (fast != null && fast.next != null) {
            slow = slow.next;         // Move slow pointer by 1
            fast = fast.next.next;    // Move fast pointer by 2
        }

        // When fast reaches the end, slow will be at the middle
        return slow;
    }
}

```