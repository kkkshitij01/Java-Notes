Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

**Example 1:**

**Input:** strs = `["flower","flow","flight"]`
**Output:** "fl"

**Example 2:**

**Input:** strs = `["dog","racecar","car"]`
**Output:** ""
**Explanation:** There is no common prefix among the input strings.

----
# Optimal Solution : 

```java
class Solution {
    public String longestCommonPrefix(String[] str) {
        // Step 1: Sort the array of strings alphabetically
        Arrays.sort(str);

        // Step 2: Compare only the first and last strings in the sorted list
        // Because they will have the smallest and largest lexicographical difference
        String first = str[0];
        String last = str[str.length - 1];

        StringBuilder sb = new StringBuilder();

        // Step 3: Compare characters of 'first' and 'last' one by one
        for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
            // If characters differ, stop and return the prefix found so far
            if (first.charAt(i) != last.charAt(i)) {
                return sb.toString();
            }
            // Otherwise, add the matching character to the result
            sb.append(first.charAt(i));
        }

        // Step 4: Return the final longest common prefix
        return sb.toString();
    }
}

```

### **Function:** `longestCommonPrefix(String[] str)`

• **Step 1:**  
 → Sort the array `str` lexicographically using `Arrays.sort(str)`.  (Sorting is done because after sorting, the **first and last strings** in the array will show the **maximum difference**, and the **common prefix** of these two will automatically be the **common prefix of all strings**.)
 → After sorting, strings that are most similar will appear near each other.

• **Step 2:**  
 → The **first** (`str[0]`) and **last** (`str[str.length - 1]`) strings in the sorted array will have the **maximum difference**.  
 → Any common prefix between these two will be shared by **all** strings in the array.

• **Step 3:**  
 → Initialize a `StringBuilder sb` to store the common prefix.  
 → Loop through both strings simultaneously up to the length of the shorter one:  
  – If characters at the same position match → append to `sb`.  
  – If they differ → break and return the current prefix.

• **Step 4:**  
 → After the loop, return the built prefix as a string.

 
###  Time Complexity: O(n log n + m), 
 → `n` = number of strings (for sorting),  
 → `m` = length of the shortest string (for comparison).  
### Space Complexity: O(1) → only uses a few variables and a `StringBuilder`.