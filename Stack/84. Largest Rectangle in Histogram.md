Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

**Input:** heights = `[2,1,5,6,2,3]`
**Output:** 10
**Explanation:** The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

**Input:** heights = `[2,4]`
**Output:** 4

---

# Approach : Most Optimal 

• We have an input array `heights[]` → heights of histogram bars.  
• Create a stack `sc` to store indices of bars.  
• Initialize `maxArea = 0` to store the maximum rectangle area found.

• Loop from `i = 0` to `heights.length` (inclusive):  
 – If `i == n` → set `currHeight = 0` → ensures all remaining bars in the stack are processed at the end.  
 – Otherwise → `currHeight = heights[i]`.

• While stack is not empty **and** `currHeight < heights[sc.peek()]`:  
 – Pop the top index from the stack → this is the bar to calculate area for.  
 – `height = heights[sc.pop()]` → height of the popped bar.  
 – `width = sc.isEmpty() ? i : i - sc.peek() - 1` → if stack is empty :- Means all the bars were greater then popped heights`[i]`
 else If stack.peek() contains the index of left next smaller of popped height & right next smaller is current height`[i]`
 – Update `maxArea = max(maxArea, height * width)` → check if this rectangle is the largest so far.
 
• Push current index `i` to the stack → may be part of future rectangles.

• After the loop, `maxArea` contains the **largest rectangle area** in the histogram.  
• Return `maxArea`.

```java
class Solution {

    public int largestRectangleArea(int[] heights) {

        int n = heights.length;

        // Stack to store indices of bars

        Stack<Integer> sc = new Stack<>();

        int maxArea = 0; // To store the maximum area found

        // Go through all bars plus one extra iteration to handle remaining bars

        for(int i = 0; i <= n; i++){

            // If we reached the end, use height 0 to flush the stack

            int currHeight = (i == n) ? 0 : heights[i];

            // If current bar is smaller than the bar at stack top, calculate area

            while(!sc.isEmpty() && currHeight < heights[sc.peek()]){

                int height = heights[sc.pop()]; // Height of the bar to calculate area

                // Width is distance between current index and new stack top after popping

                int width = sc.isEmpty() ? i : i - sc.peek() - 1; 

                // Update max area if we found a bigger one

                maxArea = Math.max(maxArea, (height * width));

            }

            // Push current index to stack

            sc.push(i);

        }

        // Return the maximum area found

        return maxArea;

    }

}
```

 
---

# Optimal

• Input array `heights[]` → heights of histogram bars.  
• Create `left[]` → stores index of nearest smaller bar on the left.  
• Create `right[]` → stores index of nearest smaller bar on the right.  
• Create a stack `sc` to help find smaller bars.

• Find nearest smaller bars on the right:  
 – Loop from right to left.  
 – Pop from stack while top ≥ current bar.  
 – If stack is empty → no smaller bar → `right[i] = heights.length`.  
 – Else → `right[i] = sc.peek()`.  
 – Push current index `i` to stack.

• Find nearest smaller bars on the left:  
 – Clear stack.  
 – Loop from left to right.  
 – Pop from stack while top ≥ current bar.  
 – If stack is empty → no smaller bar → `left[i] = -1`.  
 – Else → `left[i] = sc.peek()`.  
 – Push current index `i` to stack.

• Calculate maximum area:  
 – For each bar `i`:  
  • Width = `right[i] - left[i] - 1`.  
  • Area = `heights[i] * width`.  
  • Update `maxArea` if area is bigger.

• `right[i] = heights.length` instead of -1 → helps calculate width easily when no smaller bar on right.  
• `left[i] = -1` → helps calculate width when no smaller bar on left.

• Return `maxArea` → largest rectangle area in the histogram.
 
 ```java
 class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] left = new int[heights.length];   // Stores index of nearest smaller bar to the left
        int[] right = new int[heights.length];  // Stores index of nearest smaller bar to the right
        Stack<Integer> sc = new Stack<>();      // Stack to help find smaller bars
        
        // Find nearest smaller bar on the right for each bar
        for (int i = heights.length - 1; i >= 0; i--) {
            // Pop bars from stack until we find smaller bar
            while (!sc.isEmpty() && heights[sc.peek()] >= heights[i]) {
                sc.pop();
            }
            // If stack is empty, no smaller bar to the right
            right[i] = sc.isEmpty() ? right.length : sc.peek();
            sc.push(i); // Push current index
        }
        
        sc.clear(); // Clear stack to reuse it for left calculation
        
        // Find nearest smaller bar on the left for each bar
        for (int i = 0; i < heights.length; i++) {
            while (!sc.isEmpty() && heights[sc.peek()] >= heights[i]) {
                sc.pop();
            }
            // If stack is empty, no smaller bar to the left
            left[i] = sc.isEmpty() ? -1 : sc.peek();
            sc.push(i); // Push current index
        }
        
        int maxArea = 0; // To store maximum rectangle area
        
        // Calculate area for each bar using left and right boundaries
        for (int i = 0; i < heights.length; i++) {
            int currArea = heights[i] * (right[i] - left[i] - 1);
            maxArea = Math.max(maxArea, currArea); // Update max area
        }
        
        return maxArea; // Return the largest rectangle area
    }
}

 ```