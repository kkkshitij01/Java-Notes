Given a circular integer array `nums` (i.e., the next element of `nums[nums.length - 1]` is `nums[0]`), return _the **next greater number** for every element in_ `nums`.

The **next greater number** of a number `x` is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return `-1` for this number.

**Example 1:**

**Input:** nums = `[1,2,1]`
**Output:** `[2,-1,2]`
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.

**Example 2:**

**Input:** nums = `[1,2,3,4,3]`
**Output:** `[2,3,4,-1,4]`


---
# Appraoch:

• Create an array `ans[]` of the same length as `nums` → stores the next greater element for each position.  
• Create a stack `st` → will help find the next greater element efficiently.

• Use a **reverse loop** from `(2 * nums.length) - 1` down to `0`:  
 → We loop twice over the array to handle the **circular array** condition.

• For each index `i`:  
 – Calculate `i % nums.length` → gives the correct index even when looping the second time.  
 – While stack is **not empty** and top of stack `<= nums[i % nums.length]`:  
  • Pop elements → these cannot be the next greater for current or future elements.  
 – After popping, if the stack is empty → no greater element found → store `-1` in `ans[i % nums.length]`.  
  Otherwise → top of stack is the **next greater element**, store it in `ans[i % nums.length]`.  
 – Push `nums[i % nums.length]` onto the stack → this element may be the next greater for earlier elements.

• After the loop ends → `ans[]` contains the next greater element for every index in circular order.  
• Return `ans`.

```java 
class Solution {

    public int[] nextGreaterElements(int[] nums) {

        int[] ans = new int[nums.length]; // Array to store the next greater elements

        Stack<Integer> st = new Stack<>(); // Stack to keep track of potential next greater elements

        // Traverse the array twice (in reverse) to handle circular nature

        for (int i = (nums.length * 2) - 1; i >= 0; i--) {

            // Pop elements from stack that are smaller or equal to current element

            while (!st.isEmpty() && st.peek() <= nums[i % nums.length]) {

                st.pop();

            }

            // If stack is empty, no greater element; otherwise, top of stack is next greater

            ans[i % nums.length] = st.isEmpty() ? -1 : st.peek();

            // Push current element onto the stack

            st.push(nums[i % nums.length]);

        }

        return ans; // Return the result array

    }

}
```



