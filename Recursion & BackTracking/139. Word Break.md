Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.

**Note** that the same word in the dictionary may be reused multiple times in the segmentation.

**Example 1:**

`**Input:** s = "leetcode", wordDict = ["leet","code"]`
**Output:** true
**Explanation:** Return true because "leetcode" can be segmented as "leet code".

**Example 2:**

`**Input:** s = "applepenapple", wordDict = ["apple","pen"]`
**Output:** true
**Explanation:** Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.

**Example 3:**

`**Input:** s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]`
**Output:** false


---

# BruteForce Approach:

• **Function:** `wordBreak(String s, List<String> wordDict)`  
 → Converts `wordDict` into a `HashSet` → fast O(1) lookup.  
 → Starts recursion from index `0` by calling `solve(s, set, 0)`.

• **Function:** `solve(String s, Set<String> set, int startIdx)`  
 → Base case: if `startIdx == s.length()` → return `true` (entire string segmented).  
 → Loop over all possible substrings starting at `startIdx`.  
  – `sub = s.substring(startIdx, i + 1)` → current substring.  
  – If `sub` exists in `set` → recursively check if the rest of the string (`i + 1` to end) can be segmented.  
  – If recursion returns `true` → immediately return `true`.  
 → After trying all substrings, if none work → return `false`.

```java
class Solution {

    // Main function to check if the string can be segmented
    public boolean wordBreak(String s, List<String> wordDict) {
        int start = 0; 
        Set<String> set = new HashSet<>(wordDict); // Convert wordDict to HashSet for faster lookup
        return solve(s, set, start); // Start recursion from index 0
    }

    // Recursive function to check if substring starting at startIdx can be segmented
    public boolean solve(String s, Set<String> set, int startIdx) {
        // Base case: reached the end of the string
        if (startIdx == s.length()) {
            return true;
        }

        // Try every possible substring starting from startIdx
        for (int i = startIdx; i < s.length(); i++) {
            String sub = s.substring(startIdx, i + 1); // Current substring

            // If substring is in dictionary, check remaining string recursively
            if (set.contains(sub)) {
                if (solve(s, set, i + 1)) {
                    return true; // Found a valid segmentation
                }
            }
        }

        // No valid segmentation found starting from startIdx
        return false;
    }
}


```